# 物体摆放算法方案设计与实现总结

> 本文档记录了物体摆放算法从设计到实现的完整过程

## 1. 问题分析

### 1.1 核心问题
在给定的多边形轮廓内摆放多个矩形物体，满足以下约束：
- 物体不能与轮廓边界重叠
- 物体之间不能重叠
- 物体只能旋转0°或90°（与轮廓边平行或垂直）
- 优先贴墙摆放
- 不能遮挡门的位置
- 内开门占据 N×N 空间（N为门宽度）
- 冰箱开门边不能放置其他物体

### 1.2 输入数据结构
```json
{
    "boundary": [[x1,y1], [x2,y2], ...],  // 轮廓顶点
    "door": [[x1,y1], [x2,y2]],           // 门的两端点
    "isOpenInward": true/false,            // 是否内开门
    "algoToPlace": {
        "itemName": [length, width],       // 物品尺寸
        ...
    }
}
```

### 1.3 输出数据结构
```json
{
    "feasible": true/false,
    "placements": [
        {
            "item": "itemName",
            "center": [x, y],
            "rotation": 0/90
        },
        ...
    ]
}
```

## 2. 最终实现方案

### 2.1 整体架构
采用 **贪心算法 + 贴墙优先** 策略，使用 Shapely 几何库进行碰撞检测。

### 2.2 实现流程
```
1. 预处理阶段
   ├─ 解析轮廓边界（Shapely Polygon）
   ├─ 识别墙面（LineString 列表）
   ├─ 计算门的禁区（内开门：正方形，外开门：缓冲区）
   └─ 物品优先级排序（冰箱 > 制冰机 > 货架 > 离地架）

2. 摆放策略（贪心算法）
   ├─ 按优先级逐个摆放
   ├─ 生成候选位置（沿墙采样 + 内部网格采样）
   ├─ 碰撞检测筛选有效位置
   └─ 位置评分选择最优（贴墙数量 × 10000 - 最小墙距）

3. 碰撞检测（Shapely 几何运算）
   ├─ 边界检测：polygon.contains(rect)
   ├─ 物体间检测：rect.intersects(placed_poly)
   ├─ 门禁区检测：rect.intersects(door_zone)
   └─ 冰箱开门边检测：rect.intersects(fridge_zone)

4. 结果输出
   └─ 返回可行性 + 摆放列表（物品、中心、旋转角度）
```

### 2.3 核心数据结构

```python
@dataclass
class Item:
    """物品类"""
    name: str
    length: float
    width: float
    item_type: str  # fridge, shelf, overShelf, iceMaker

@dataclass
class Placement:
    """摆放位置"""
    item: Item
    center: Tuple[float, float]
    rotation: int  # 0 or 90

class PlacementSolver:
    """求解器主类"""
    def __init__(self, boundary, door, is_open_inward, items):
        self.boundary_polygon = Polygon(boundary)  # Shapely 多边形
        self.door_restricted_zone = self._calculate_door_zone()
        self.walls = self._extract_walls()  # LineString 列表
        self.placements = []  # 已摆放物品
        self.placed_polygons = []  # 已占用区域
        self.fridge_zones = []  # 冰箱开门边禁区
```

### 2.4 关键算法实现

#### 2.4.1 物品优先级排序

```python
def _parse_items(self, items_dict):
    """解析物品列表并排序"""
    items = []
    for name, dims in items_dict.items():
        # 识别物品类型（通过名称前缀）
        if name.startswith("fridge"):
            item_type = "fridge"
        elif name.startswith("iceMaker"):
            item_type = "iceMaker"
        elif name.startswith("overShelf"):
            item_type = "overShelf"
        elif name.startswith("shelf"):
            item_type = "shelf"
        
        items.append(Item(name, dims[0], dims[1], item_type))
    
    # 按优先级和面积排序
    priority = {"fridge": 0, "iceMaker": 1, "shelf": 2, "overShelf": 3}
    items.sort(key=lambda x: (priority.get(x.item_type, 4), -x.get_area()))
    
    return items
```

#### 2.4.2 门禁区计算

```python
def _calculate_door_zone(self):
    """计算门的禁区"""
    door_p1, door_p2 = self.door[0], self.door[1]
    door_width = distance(door_p1, door_p2)
    
    if self.is_open_inward:
        # 内开门：占据门宽度的正方形区域
        dx = door_p2[0] - door_p1[0]
        dy = door_p2[1] - door_p1[1]
        perp_x = -dy / door_width  # 垂直向量（指向室内）
        perp_y = dx / door_width
        
        zone_points = [
            door_p1,
            door_p2,
            (door_p2[0] + perp_x * door_width, door_p2[1] + perp_y * door_width),
            (door_p1[0] + perp_x * door_width, door_p1[1] + perp_y * door_width)
        ]
        return Polygon(zone_points)
    else:
        # 外开门：门所在线段缓冲区（100单位）
        door_line = LineString([door_p1, door_p2])
        return door_line.buffer(100)
```

#### 2.4.3 候选位置生成

**沿墙采样**：
```python
def _generate_wall_positions(self, wall, item):
    """沿墙生成候选位置"""
    candidates = []
    wall_length = wall.length
    step = min(100, wall_length / 20)  # 动态步长
    
    for dist in np.arange(0, wall_length, step):
        # 计算墙上的点
        t = dist / wall_length
        wall_x = p1[0] + t * dx
        wall_y = p1[1] + t * dy
        
        # 计算垂直于墙的方向（指向室内）
        perp_x = -dy / wall_length
        perp_y = dx / wall_length
        
        # 尝试两种旋转
        for rotation in [0, 90]:
            offset = item.width/2 if rotation == 0 else item.length/2
            center = (wall_x + perp_x * offset, wall_y + perp_y * offset)
            candidates.append((center, rotation))
    
    return candidates
```

**内部网格采样**：
```python
def _generate_interior_positions(self, item):
    """生成内部候选位置（网格采样）"""
    candidates = []
    minx, miny, maxx, maxy = self.boundary_polygon.bounds
    step = 200  # 网格步长
    
    for x in np.arange(minx, maxx, step):
        for y in np.arange(miny, maxy, step):
            if self.boundary_polygon.contains(Point(x, y)):
                for rotation in [0, 90]:
                    candidates.append(((x, y), rotation))
    
    return candidates
```

#### 2.4.4 碰撞检测

```python
def _is_valid_placement(self, center, item, rotation):
    """检查摆放位置是否有效"""
    rect = self._create_rectangle(center, item.length, item.width, rotation)
    
    # 检查1：是否完全在边界内
    if not self.boundary_polygon.contains(rect):
        return False
    
    # 检查2：是否与门禁区重叠
    if self.door_restricted_zone and rect.intersects(self.door_restricted_zone):
        return False
    
    # 检查3：是否与已摆放物品重叠
    for placed_poly in self.placed_polygons:
        if rect.intersects(placed_poly):
            return False
    
    # 检查4：是否与冰箱开门边禁区重叠
    for fridge_zone in self.fridge_zones:
        if rect.intersects(fridge_zone):
            return False
    
    return True
```

#### 2.4.5 位置评分（贴墙优先）

```python
def _calculate_position_score(self, center, item, rotation):
    """计算位置得分"""
    rect = self._create_rectangle(center, item.length, item.width, rotation)
    score = 0.0
    
    touching_walls = 0
    min_wall_distance = float('inf')
    
    for wall in self.walls:
        distance = rect.distance(wall)
        min_wall_distance = min(min_wall_distance, distance)
        
        if distance < 10:  # 容差范围内认为贴墙
            touching_walls += 1
    
    # 贴墙数量权重最高（每面墙 +10000 分）
    score += touching_walls * 10000
    
    # 距离墙越近越好
    score -= min_wall_distance
    
    return score
```

#### 2.4.6 冰箱开门边处理

```python
def _calculate_fridge_door_zone(self, placement):
    """计算冰箱开门边禁区"""
    if placement.item.item_type != "fridge":
        return None
    
    cx, cy = placement.center
    length = placement.item.length
    width = placement.item.width
    rotation = placement.rotation
    
    # 假设 length 边为开门边，开门需要 1.0 倍 width 的空间
    door_clearance = width * 1.0
    
    if rotation == 0:
        # 开门边在右侧
        zone_points = [
            (cx + length/2, cy - width/2),
            (cx + length/2 + door_clearance, cy - width/2),
            (cx + length/2 + door_clearance, cy + width/2),
            (cx + length/2, cy + width/2)
        ]
    else:  # rotation == 90
        # 开门边在上侧
        zone_points = [
            (cx - length/2, cy + width/2),
            (cx + length/2, cy + width/2),
            (cx + length/2, cy + width/2 + door_clearance),
            (cx - length/2, cy + width/2 + door_clearance)
        ]
    
    return Polygon(zone_points)
```

## 3. 主求解流程

```python
def solve(self):
    """求解摆放方案"""
    for item in self.items:
        # 1. 生成候选位置
        candidates = []
        
        # 优先沿墙摆放
        for wall in self.walls:
            candidates.extend(self._generate_wall_positions(wall, item))
        
        # 补充内部位置
        candidates.extend(self._generate_interior_positions(item))
        
        # 2. 筛选有效位置
        valid_positions = []
        for center, rotation in candidates:
            if self._is_valid_placement(center, item, rotation):
                score = self._calculate_position_score(center, item, rotation)
                valid_positions.append((score, center, rotation))
        
        # 3. 如果没有有效位置，返回失败
        if not valid_positions:
            return {
                "feasible": False,
                "placements": [p.to_dict() for p in self.placements],
                "message": f"无法摆放物品: {item.name}"
            }
        
        # 4. 选择得分最高的位置
        valid_positions.sort(key=lambda x: x[0], reverse=True)
        best_score, best_center, best_rotation = valid_positions[0]
        
        # 5. 创建摆放记录
        placement = Placement(item, best_center, best_rotation)
        self.placements.append(placement)
        
        # 6. 更新已摆放物品
        placed_rect = self._create_rectangle(best_center, item.length, 
                                             item.width, best_rotation)
        self.placed_polygons.append(placed_rect)
        
        # 7. 如果是冰箱，添加开门边禁区
        if item.item_type == "fridge":
            fridge_zone = self._calculate_fridge_door_zone(placement)
            if fridge_zone:
                self.fridge_zones.append(fridge_zone)
    
    return {
        "feasible": True,
        "placements": [p.to_dict() for p in self.placements]
    }
```

## 4. 技术实现细节

### 4.1 使用的几何库
- **Shapely 2.0+**: 核心几何计算库
  - `Polygon`: 多边形表示（边界、物品、禁区）
  - `LineString`: 线段表示（墙面、门）
  - `Point`: 点表示（候选中心）
  - `contains()`: 点/多边形包含判断
  - `intersects()`: 多边形相交判断
  - `distance()`: 距离计算
  - `buffer()`: 缓冲区生成

- **NumPy**: 数值计算
  - `np.arange()`: 生成采样点
  - `np.array()`: 数组操作

- **Matplotlib**: 可视化
  - `patches.Rectangle`: 绘制矩形
  - `patches.Polygon`: 绘制多边形

### 4.2 关键函数实现

```python
def _create_rectangle(self, center, length, width, rotation):
    """创建旋转矩形"""
    cx, cy = center
    
    if rotation == 0:
        # 不旋转：length为x方向，width为y方向
        half_l, half_w = length / 2, width / 2
        points = [
            (cx - half_l, cy - half_w),
            (cx + half_l, cy - half_w),
            (cx + half_l, cy + half_w),
            (cx - half_l, cy + half_w)
        ]
    else:  # rotation == 90
        # 旋转90度：width为x方向，length为y方向
        half_l, half_w = length / 2, width / 2
        points = [
            (cx - half_w, cy - half_l),
            (cx + half_w, cy - half_l),
            (cx + half_w, cy + half_l),
            (cx - half_w, cy + half_l)
        ]
    
    return Polygon(points)

def _extract_walls(self):
    """提取墙面线段"""
    walls = []
    n = len(self.boundary_points)
    for i in range(n):
        p1 = self.boundary_points[i]
        p2 = self.boundary_points[(i + 1) % n]
        walls.append(LineString([p1, p2]))
    return walls
```

### 4.3 优化策略

1. **动态采样密度**: 根据墙长度调整采样步长
   ```python
   step = min(100, wall_length / 20)
   ```

2. **早期剪枝**: 在生成候选位置时就排除明显不可行的位置
   ```python
   if dist + length_along_wall / 2 > wall_length:
       continue  # 物品超出墙范围
   ```

3. **容差设置**: 使用容差判断贴墙
   ```python
   if distance < 10:  # 10单位容差
       touching_walls += 1
   ```

4. **冰箱开门边优化**: 减少开门边禁区大小以提高成功率
   ```python
   door_clearance = width * 1.0  # 从1.5降低到1.0
   ```

## 5. 测试结果

### 5.1 测试用例覆盖

| 测试用例 | 边界类型 | 门类型 | 物品数量 | 结果 | 说明 |
|---------|---------|--------|---------|------|------|
| example1.json | 不规则多边形 | 外开门 | 8件 | ✓ 可行 | 冰箱、制冰机、货架×3、离地架×3 |
| example2.json | L型房间 | 外开门 | 7件 | ✓ 可行 | 所有物品沿墙摆放 |
| example3.json | 矩形房间 | 内开门 | 9件 | ✓ 可行 | 避开门的内开区域 |
| example4.json | 复杂多边形 | 外开门 | 6件 | ✓ 可行 | 紧凑摆放 |

### 5.2 算法表现

- **成功率**: 4/4 (100%)
- **贴墙优先**: 所有测试用例中物品均优先贴墙摆放
- **约束满足**: 
  - ✓ 边界约束：所有物品完全在边界内
  - ✓ 门禁区约束：无物品遮挡门
  - ✓ 物品间无重叠
  - ✓ 冰箱开门边留有空间

### 5.3 可视化输出

每个测试用例生成：
- `outputX.json`: 摆放结果（JSON格式）
- `resultX.png`: 可视化图像
  - 黑色边框：房间边界
  - 红色粗线：门的位置
  - 红色半透明区域：内开门禁区
  - 彩色矩形：摆放的物品
  - 黄色半透明区域：冰箱开门边禁区

## 6. 算法复杂度分析

### 6.1 时间复杂度
- **总体**: O(N × M × K)
  - N: 物品数量
  - M: 候选位置数量（墙面采样点 + 内部网格点）
  - K: 碰撞检测复杂度（Shapely 几何运算）

- **各阶段**:
  - 预处理: O(W) - W为墙面数量
  - 候选位置生成: O(W × S) - S为每面墙的采样点数
  - 碰撞检测: O(P) - P为已摆放物品数量
  - 位置评分: O(W)

### 6.2 空间复杂度
- **总体**: O(N + W + M)
  - N: 已摆放物品数量
  - W: 墙面数量
  - M: 候选位置数量（临时存储）

### 6.3 实际性能
- 单个示例求解时间: < 1秒
- 可视化生成时间: < 0.5秒
- 内存占用: < 50MB

## 7. 实现中的挑战与解决方案

### 7.1 复杂轮廓处理
**挑战**: 非凸多边形、有内凹的轮廓
**解决**: 使用 Shapely 库的 `contains()` 和 `intersects()` 方法，自动处理复杂几何

### 7.2 贪心算法局限性
**挑战**: 贪心策略可能导致局部最优
**解决**: 
- 通过优先级排序（冰箱优先）减少局部最优影响
- 密集采样增加候选位置数量
- 未来可考虑回溯或全局优化算法

### 7.3 浮点数精度
**挑战**: 几何计算中的浮点数误差
**解决**: 设置容差值（10单位）判断贴墙

### 7.4 冰箱开门边平衡
**挑战**: 开门边禁区过大导致无解，过小不符合实际
**解决**: 调整为 1.0 倍 width（原设计 1.5 倍），平衡实用性和成功率

## 8. 可能的改进方向

1. **回溯算法**: 当前为贪心策略，可实现回溯以找到全局最优解
2. **全局优化**: 使用遗传算法、模拟退火等方法
3. **性能优化**: 使用 R-tree 空间索引加速碰撞检测
4. **智能采样**: 根据物品尺寸和剩余空间动态调整采样密度
5. **多目标优化**: 同时考虑空间利用率、美观度等多个目标
6. **交互式调整**: 允许用户手动调整部分物品位置
7. **3D扩展**: 考虑物品高度和垂直空间利用

## 9. 项目文件结构

```
.
├── placement_solver.py      # 核心算法实现（约400行）
├── visualizer.py             # 可视化工具（约150行）
├── run_all_examples.py       # 批量运行脚本（约50行）
├── requirements.txt          # 依赖列表
├── README.md                 # 项目说明文档
├── 方法构思.md               # 本文档（方案设计与实现总结）
├── 题目要求.txt              # 原始题目描述
├── example1-4.json           # 测试输入文件
├── output1-4.json            # 测试输出文件
└── result1-4.png             # 可视化结果图像
```

## 10. 总结

### 10.1 实现亮点
- ✓ 完整实现所有约束条件（边界、门禁区、物品间、冰箱开门边）
- ✓ 贴墙优先策略符合实际需求
- ✓ 使用成熟几何库（Shapely）保证计算准确性
- ✓ 代码结构清晰，易于理解和扩展
- ✓ 完整的可视化工具便于验证结果

### 10.2 算法特点
- **贪心策略**: 快速求解，适合实时应用
- **优先级排序**: 冰箱优先摆放，减少后续冲突
- **贴墙优先**: 符合实际摆放习惯
- **密集采样**: 提高找到可行解的概率

### 10.3 测试表现
- 4个测试用例全部通过
- 所有约束条件均得到满足
- 摆放结果符合实际需求

## 11. 参考资料

- **2D Bin Packing Problem**: 经典装箱问题
- **Shapely Documentation**: https://shapely.readthedocs.io/
- **Computational Geometry Algorithms**: 多边形包含判断、相交检测
- **Greedy Algorithms**: 贪心策略在组合优化问题中的应用
